# Scope Proposal & Explainer

NOTE: This explainer may be out of date,
since work is now happening
on the official specification:
[CSS Cascade & Inheritance Module level 6](https://drafts.csswg.org/css-cascade-6/#scoped-styles).

## Authors

- Miriam Suzanne

## Participate

Please leave any feedback on the CSSWG issues for this proposal:

- [Proposal for light-dom scoping/namespacing](https://github.com/w3c/csswg-drafts/issues/5809)
- [Request for TAG review](https://github.com/w3ctag/design-reviews/issues/593)

Typos or other document-specific issues
[can be reported in this repo](https://github.com/oddbird/css-sandbox/issues).

## Table of contents

<!-- generated by VSCode Markdown All-In-One extension -->

- [Authors](#authors)
- [Participate](#participate)
- [Table of contents](#table-of-contents)
- [Introduction](#introduction)
- [Goals](#goals)
  - [The namespace problem](#the-namespace-problem)
  - [The nearest-ancestor "proximity" problem](#the-nearest-ancestor-proximity-problem)
  - [The lower-boundary, or "ownership" problem (aka "donut scope")](#the-lower-boundary-or-ownership-problem-aka-donut-scope)
  - [Popular tooling for modular CSS](#popular-tooling-for-modular-css)
- [Non-goals](#non-goals)
- [Proposed Solution](#proposed-solution)
  - [Re-introducing the `@scope` rule](#re-introducing-the-scope-rule)
  - [The (existing) `:scope` pseudo-class](#the-existing-scope-pseudo-class)
  - [A new donut selector?](#a-new-donut-selector)
  - [Scope in the cascade](#scope-in-the-cascade)
    - [Specificity](#specificity)
    - [Scope Proximity](#scope-proximity)
- [Key scenarios](#key-scenarios)
  - [Avoid naming conflicts without custom conventions](#avoid-naming-conflicts-without-custom-conventions)
  - [Express ownership boundaries in nested components](#express-ownership-boundaries-in-nested-components)
  - [Recursive nesting with ownership](#recursive-nesting-with-ownership)
  - [Recognizing proximity of nested components without lower-bounds](#recognizing-proximity-of-nested-components-without-lower-bounds)
  - [JS tools & "single file components"](#js-tools--single-file-components)
- [Detailed design discussion & alternatives](#detailed-design-discussion--alternatives)
  - [Should we be building on Shadow DOM?](#should-we-be-building-on-shadow-dom)
  - [Are scope attributes useful in html?](#are-scope-attributes-useful-in-html)
  - [Would we need special handling around the shadow-DOM?](#would-we-need-special-handling-around-the-shadow-dom)
  - [Can tree-abiding pseudo elements be scope roots?](#can-tree-abiding-pseudo-elements-be-scope-roots)
  - [A JS API for fetching "donut scope" elements?](#a-js-api-for-fetching-donut-scope-elements)
  - [How does scope interact with the nesting module?](#how-does-scope-interact-with-the-nesting-module)
  - [Can scope rules be nested in other scope rules?](#can-scope-rules-be-nested-in-other-scope-rules)
  - [What happens when the root element matches the lower-boundary?](#what-happens-when-the-root-element-matches-the-lower-boundary)
  - [Where does scope fit in the cascade?](#where-does-scope-fit-in-the-cascade)
    - [The 2014 scope proposal](#the-2014-scope-proposal)
    - [Shadow-DOM encapsulation context](#shadow-dom-encapsulation-context)
    - [The case for less isolation, and weak proximity](#the-case-for-less-isolation-and-weak-proximity)
    - [Alternative approaches to specificity](#alternative-approaches-to-specificity)
  - [Can we improve on the syntax?](#can-we-improve-on-the-syntax)
- [Spec History & Context](#spec-history--context)
  - [CSS Scoping](#css-scoping)
  - [CSS Selectors - Level 4](#css-selectors---level-4)
  - [CSS Cascade - Level 4](#css-cascade---level-4)
- [Stakeholder Feedback / Opposition](#stakeholder-feedback--opposition)
- [References & acknowledgements](#references--acknowledgements)
- [Change log](#change-log)
  - [2021.01.29](#20210129)
  - [2021.01.29](#20210129-1)
  - [2021.01.28](#20210128)
  - [2021.01.27](#20210127)
  - [2021.01.18](#20210118)

## Introduction

There are many overlapping
and sometimes contradictory features
that can live under the concept of "scope" in CSS --
but they divide roughly into two approaches:

1. Total isolation of a component DOM subtree/fragment from the host page,
   so that no selectors get in or out
   unless explicitly requested.
2. Lighter-touch, style-driven namespacing,
   and prioritization of "proximity"
   when resolving the cascade.

That has lead to a wide range of proposals over the years,
including a [scope specification][initial-spec]
that was never implemented.
Focus moved to Shadow-DOM,
which is mainly concerned with approach #1 -- full isolation.
Meanwhile authors have attempted to handle approach #2
through convoluted naming conventions (like [BEM][])
and JS tooling
(such as [CSS Modules][], [Styled Components][], & [Vue Scoped Styles][]).

This document is proposing a native CSS approach
for what many authors are already doing
with those third-party tools & conventions.

[initial-spec]: https://www.w3.org/TR/css-scoping-1/
[BEM]: http://getbem.com/
[CSS Modules]: https://github.com/css-modules/css-modules
[Styled Components]: https://styled-components.com/
[Vue Scoped Styles]: https://vue-loader.vuejs.org/guide/scoped-css.html

## Goals

### The namespace problem

All CSS Selectors are global,
matching against the entire DOM.
As projects grow,
or adapt a more modular "component-composition" approach,
it can be hard to track what names have been used,
and avoid conflicts.

To solve this,
authors rely on
convoluted naming conventions (BEM)
and JS tooling (CSS Modules & Scoped Styles)
to "isolate" selector matching inside a single "component".

BEM helps authors by ensuring that only
component "blocks" need unique naming:

```css
.media { /* block */ }
.tabs { /* block */ }
```

Meanwhile,
any internal "elements" or "modifiers"
will be scoped to the block:

```css
.media--reverse { /* modifier */ }
.media__img { /* element */ }
.media__text { /* element */ }

.tabs--left { /* modifier */ }
.tabs__list { /* element */ }
.tabs__panel { /* element */ }
```

### The nearest-ancestor "proximity" problem

Ancestor selectors allow us to
filter the "scope" of nested selectors
to a sub-tree in the DOM:

```css
/* link colors for light and dark backgrounds */
.light-theme a { color: purple; }
.dark-theme a { color: plum; }
```

But problems show up quickly
when you start thinking of these as modular styles
that should nest in any arrangement.

```html
<div class="dark-theme">
  <a href="#">plum</a>

  <div class="light-theme">
    <a href="#">also plum???</a>
  </div>
</div>
```

Our selectors appropriately have the same specificity,
but they are not weighted by
"proximity" to the element being styled.
Instead we fallback to source order,
and `.dark-theme` will always take precedence.

There is no selector/specificity solution
that accurately reflects what we want here --
with the "nearest ancestor" taking precedence.

This was one of the
[original issues highlighted by OOCSS][oocss-proximity]
in 2009.

[oocss-proximity]: https://www.slideshare.net/stubbornella/object-oriented-css/62-CSS_WISH_LIST

### The lower-boundary, or "ownership" problem (aka "donut scope")

While "proximity" is loosely concerned with nesting styles,
the problem comes into more focus
with the concept of modular components --
which can be more complex.

To use BEM terminology,
Components are generally comprised of:

- An outer "block" or component wrapper
- Inner "elements" that belong to that block explicitly
- Occasional "donut holes" or "slots" where sub-components can be nested

In html templating languages,
and JS frameworks,
this can be represented by an "include"
or "single file component".

BEM attempts to convey this "ownership" in CSS:

```css
/* any title inside the component tree */
.component .title { /* too broad */ }

/* only a title that is a direct child of the component */
.component > .title { /* too limiting of DOM structures */ }

/* just the title of the component */
.component__title { /* just right? */ }
```

Nicole Sullivan coined the term
["donut" scope][donut] for this issue in 2011 --
because the scope can have a hole in the middle.
It would be useful for authors
to express this DOM-fragment
"ownership" more clearly in native HTML/CSS.

[donut]: http://www.stubbornella.org/content/2011/10/08/scope-donuts/

### Popular tooling for modular CSS

CSS Modules, Vue, Styled-JSX, and other tools
often use a similar pattern
(with slight variations to syntax) --
where "scoped" selectors only apply to
the locally described DOM fragment,
and not descendants.

In Vue single file components,
authors can write html templates
with "scoped" style blocks:

```html
<!-- component.vue -->
<template>
  <section class="component">
    <div class="element">...<div>
    <sub-component>...</sub-component>
  </section>
</template>

<style scoped>
.component { /* ... */ }
.element { /* ... */ }
.sub-component { /* ... */ }
</style>

<!-- sub-component.vue -->
<template>
  <section class="sub-component">
    <div class="element">...<div>
  </section>
</template>

<style scoped>
.sub-component { /* ... */ }
.element { /* ... */ }
</style>
```

While the language is similar to shadow-DOM in many ways,
the output is quite different --
and much less isolated.
The components remain part of the global scope,
and only the explicitly "scoped" styles are contained.
That's often achieved by automatically adding unique attributes
to each element based on the component(s) it belongs to:

```html
<section class="component" scope="component">
  <div class="element" scope="component">...<div>

  <!-- nested component "shell" is in both scopes -->
  <section class="sub-component" scope="component sub-component">
    <div class="element" scope="sub-component">...<div>
  </section>
</section>
```

And matching attributes are added to each selector:

```css
/* component.vue styles after scoping */
.component[scope=component] { /* ... */ }
.element[scope=component] { /* ... */ }
.sub-component[scope=component] { /* ... */ }

/* sub-component.vue styles after scoping */
/* note that both style `.element` without any overlap or naming conflicts */
.sub-component[scope=sub-component] { /* ... */ }
.element[scope=sub-component] { /* ... */ }
```

- The donut is achieved by selectively adding attributes
- Proximity-weight is achieved only through limiting the donut of scope,
  so that outer values are less likely to "bleed" in
- Added attribute gives scoped styles _some_ (but very little)
  extra specificity weight in the cascade

## Non-goals

There is a more extreme isolation use-case.
It's mostly used for "widgets" that will appear unchanged
across multiple projects --
but sometimes also in component libraries
on larger projects.

Full isolation blocks off a fragment of the DOM,
so that it _only_ accepts styles that are
explicitly scoped.
General page styles do not apply.

I don't think this is the most common concern for authors,
but it has received the most attention.
Shadow DOM is entirely constructed around this behavior.

I have not attempted to address that form of scope in my proposal --
it feels like a significantly different approach
that already has work underway.

See Yu Han's proposals for
[building on shadow DOM](#should-we-be-building-on-shadow-dom)
below.

## Proposed Solution

### Re-introducing the `@scope` rule

_This would likely belong in
the [CSS Scoping Module](https://drafts.csswg.org/css-scoping/)._

In the long-standing
["Bring Back Scope"](https://github.com/w3c/csswg-drafts/issues/3547)
issue-thread,
Giuseppe Gurgone
[suggests a syntax](https://github.com/w3c/csswg-drafts/issues/3547#issuecomment-524206816) building on the original un-implemented `@scope` spec,
but adding a lower boundary:

```css
@scope (from: .carousel) and (to: .carousel-slide-content) {
  p { color: red }
}
```

I think that's a good place to start.

In my mind, the first ("from") clause may not need explicit labeling.
It would accept a single (complex) selector
(or selector list?):

```css
@scope (.media-block) {
  img { border-radius: 50%; }
}
```

In terms of selector-matching,
this would be the same as
`.media-block img`,
but with slightly different cascade implications
([see cascade section](#scope-proximity-in-the-cascade)).

The second ("to") clause would be optional,
and accept a list of selectors
that represent lower-boundary "slots" in the scope.
The targeted lower-boundary elements are included in the scope,
but their descendants are not:

```css
@scope (.media-block) to (.content) {
  img { border-radius: 50%; }
  .content { padding: 1em; }
}
```

Which would only match `img` and `.content`
inside `.media-block` --
_but not if there are intervening `.content`
between the scope root and selector target_:

```html
<div class="media-block">
  <img src="..."><!-- this img is in the .media-block scope -->
  <div class="content"><!-- this .content is in-scope -->
    <img src="..."><!-- this img is NOT -->
    <div class="more content">...</div><!-- this .content is NOT -->
  </div>
</div>
```

This approach keeps scoping confined to CSS
(no need for a new HTML attribute),
flexible
(scopes can overlap as needed),
and low-impact
(global styles continue to work as expected).
Existing tools would still be able to
provide syntax sugar for single-file components --
automatically generating the from/to clauses --
but move the primary functionality into CSS.

Finally, we could allow `@scope` without any selector clauses, which would scope the styles to the parent of the stylesheet's owner node (or the containing tree for constructable stylesheets with no owner node).

```html
<div>
  <style>
    @scope {
      p { color: red; }
    }
  </style>
  <p>this is red</p>
</div>
<p>not red</p>
```

That would be equivalent to:

```html
<div id="foo">
  <style>
    @scope (#foo) {
      p { color: red; }
    }
  </style>
  <p>this is red</p>
</div>
<p>not red</p>
```

### The (existing) `:scope` pseudo-class

In most cases we can infer
that the `@scope` root selector
is prepended to all internal selectors
with an ancestor/descendant relationship:

```css
@scope (.media) {
  img { /* .media img */ }
  .content { /* .media .content */ }
}
```

There is even an existing
[Reference Element Pseudo-class][scope-class]
(`:scope` selector),
which we can use to represent that behavior.
It is currently supported in JS APIs
to refer to the base element of e.g. `element.querySelector()`.
The following blocks would be identical:

```css
@scope (.media) {
  img { /* .media img */ }
  .content { /* .media .content */ }
}

@scope (.media) {
  :scope img { /* .media img */ }
  :scope .content { /* .media .content */ }
}
```

Authors can also use `:scope`
to express more complex relationships
between a scoped selector and the scope-root.
For example, adding an explicit combinator:

```css
@scope (.media) {
  :scope > img { object-fit: cover; }
}
```

Or matching based on additional context outside the scope:

```css
@scope (.media) {
  .sidebar :scope img { object-fit: cover; }
}
```

Or styling the scope-root directly:

```css
@scope (.media) {
  :scope { display: grid; }
}
```

This is especially useful
if we want to target a nested instance
of the scope root selector:

```css
@scope (.media) {
  /* select only the scope-root .media  */
  :scope { display: grid; }

  /* select nested .media inside the scope */
  .media { background: gray; }
  :scope .media { background: gray; }
}
```

Since there is no way
to have the root element inside itself,
we would not support nested instances of `:scope` itself:

```css
@scope (.media) {
  /* no match */
  :scope :scope { background: gray; }
  :scope + :scope { background: gray; }
}
```

Note: There has also been some discussion
of using the [nesting module][nesting]
`&` nested-selector for this.
But `&` acts as an alias for duplicating a selector list,
while `:scope` refers to a specific element
that is acting as the root of a given context.
Given the likelihood that
nesting and scope will be used together,
it seemed important that these ideas remain distinct.

### A new donut selector?

Lea Verou has suggested
that it might be useful for authors
to access "donut-matching" as a distinct feature,
apart from the cascade rules of scoping.

That could be done with a pseudo-selector.
The name would need bike-shedding,
but let's call it `in()` for now.
This new selector would need to describe the entire donut,
taking two arguments:
a root selector,
and lower-boundary selector.
Since spaces and commas exist inside selectors,
we could borrow the slash as a delimiter.
Imagine a syntax like:

```css
/* :in(<selector> / <selector>) */
:in(.root .selector / .lower, .boundaries)
```

The following selectors
would match the same elements:

```css
@scope (.media) to (.content) {
  img { border: red; }
}

img:in(.media / .content) { border: red; }
```

In practice,
there would be very little difference
between this selector and a scope rule --
since scope proximity is weighted
below specificity in the cascade.
It's not clear to me how many use-cases
would want donut-selection
while opting out from scope proximity.

I explore this idea more
as part of my [syntax comparison](/scope/syntax/).

### Scope in the cascade

The `@scope` rule has a double-impact
on the cascade of scoped selectors --
as part of specificity,
and then again in relation to proximity.

At first that seemed potentially confusing,
but after many conversations,
I think it may be the most expected behavior.

#### Specificity

There are several ways
we could handle specificity around scoping.
Assuming we support both `@scope`/`:scope`
and a selector like `:in()`,
we would likely want to match the specificity
of all these selectors:

```css
@scope (#media) to (.content) {
  img { /* implied :scope ancestor */ }
  :scope img { /* explicit :scope ancestor */ }
}

img:in(#media / .content) { /* donut selector */ }
```

Based on feedback so far,
I lean towards applying the scope-root specificity
to the overall specificity of each selector.
All the examples above
would get a specificity of `[1, 0, 1]`.

Some [alternative approaches](#alternative-approaches-to-specificity)
are discussed below.

#### Scope Proximity

_This would likely belong in
[CSS Cascading & Inheritance](https://drafts.csswg.org/css-cascade/)._

The syntax above solves the issue of
naming-conflicts, with lower-boundaries/ownership.
But the issue of _scope proximity_ requires changes in the Cascade.
My sense is that scope proximity
should override _source order_,
but otherwise cascade layers & specificity
should take precedence.

Given the same origin & importance, layering, and specificity --
inner "more proximate" scope would take precedence
over outer/global "less proximate" scopes:

```css
@scope (.light-theme) {
  a { color: purple; }
}

@scope (.dark-theme) {
  a { color: plum; }
}
```

```html
<div class="dark-theme">
  <a href="#">plum</a>

  <div class="light-theme">
    <a href="#">purple</a>
  </div>
</div>
```

Given the same proximity of multiple scopes,
source order would continue to be the final cascade filter:

```css
@scope (.light-theme) {
  a { color: purple; }
}

@scope (.special-links) {
  a { color: maroon; }
}
```

```html
<div class="special-links light-theme">
  <a href="#">maroon</a>
</div>
```

However, in this proposal
**specificity can override scope proximity**.
Given the following CSS,
a paragraph matched by both rules
would be `red`,
thanks to the added specificity:

```css
@scope aside {
 p { color: green; }
}

aside#sidebar p { color: red; }
```

This is a major departure from both
the [original scope specification][initial-spec]
and Shadow-DOM [encapsulation context][],
which override specificity.
That is useful in certain cases,
but many authors desire a lighter-touch scope --
allowing global styles to easily flow through scoped components,
while preventing scoped styles from leaking out.

I [discuss this in more detail below](#where-does-scope-fit-in-the-cascade).

## Key scenarios

### Avoid naming conflicts without custom conventions

Authors currently rely on intricate naming conventions
to avoid duplicate naming within components:

```css
.article__title {
  font-size: 2em;
}
.article__meta {
  font-size: 2em;
}

.form__title {
  font-weight: bold;
}
.form__meta {
  font-weight: bold;
}
```

Sometimes authors will automate that process,
and group names visually,
using nested syntax in a pre-processor like Sass:

```scss
.article {
  &__title { font-size: 2em; }
  &__meta { font-style: italic; }
}

.form {
  &__title { font-weight: bold; }
  &__meta { text-align: center; }
}
```

This syntax would provide a uniform solution
that is native to CSS.
Authors can reduce naming conflicts
across CSS "components"/"objects"
by scoping internal selectors
so they only match within a particular block:

```css
@scope (article) {
  .title { font-size: 2em; }
  .meta { font-style: italic; }
}

@scope (form) {
  .title { font-weight: bold; }
  .meta { text-align: center; }
}
```

### Express ownership boundaries in nested components

By adding lower boundaries or "slots" to the scope,
ownership becomes more clear
when the scopes are nested.

Using the example above,
we can allow comment forms to be nested inside articles
while continuing to maintain the
distinction between article-elements
and form-elements:

```css
@scope (article) to (.comments) {
  .title { font-size: 2em; }
  .meta { font-style: italic; }
}

@scope (form) {
  .title { font-weight: bold; }
  .meta { text-align: center; }
}
```

### Recursive nesting with ownership

This can also be useful
when applying modifiers to components
that might nest indefinitely --
such as the popular "media-object"
containing a fixed image and responsive content
that flows around it.
Modifiers can be added to an outer component
without impacting nested components of the same type.

For example,
nested "media objects"
of different types:

```html
<div class="media reverse">
  <img src="...">
  <div class="content">
    <div class="media">
      <img src="...">
      <div class="content">
      </div>
    </div>
  </div>
</div>
```

Rather than adding the `.reverse` modifier
to every element in the outer media block,
we can scope the effects of the modifier:

```css
@scope (.media) to (.content) {
  /* only the inner image */
  :scope:not(.reverse) img { margin-right: 1em; }

  /* only the outer image */
  :scope.reverse img { margin-left: 1em; }
}
```

### Recognizing proximity of nested components without lower-bounds

As [demonstrated above](#scope-proximity-in-the-cascade),
authors could establish
scope precedence
even when lower bounds are not required.
For example,
light and dark themes
that can be nested
in any arrangement:

```css
@scope (.light-theme) {
  a { color: purple; }
}

@scope (.dark-theme) {
  a { color: plum; }
}
```

```html
<div class="dark-theme">
  <a href="#">plum</a>

  <div class="light-theme">
    <a href="#">purple</a>

    <div class="dark-theme">
      <a href="#">plum again</a>
    </div>
  </div>
</div>
```

### JS tools & "single file components"

Existing tools could move to automating
this syntax over time,
rather than using custom attributes,
since the result is very similar.
Without any changes visible to the user,
output that currently looks like:

```css
/* component.vue styles after scoping */
.component[scope=component] { /* ... */ }
.element[scope=component] { /* ... */ }
.sub-component[scope=component] { /* ... */ }

/* sub-component.vue styles after scoping */
/* note that both style `.element` without any overlap or naming conflicts */
.sub-component[scope=sub-component] { /* ... */ }
.element[scope=sub-component] { /* ... */ }
```

Could be converted to:

```css
/* component.vue styles after scoping */
@scope (.component) to (.sub-component) {
  :scope { /* ... */ }
  .element { /* ... */ }
  .sub-component { /* ... */ }
}

/* sub-component.vue styles after scoping */
@scope (.sub-component) {
  :scope { /* ... */ }
  .element { /* ... */ }
}
```

## Detailed design discussion & alternatives

### Should we be building on Shadow DOM?

this is often the first question asked
of any scope-related proposal,
for good reason.
Shadow-DOM was designed for the express purpose
of encapsulating styles & behavior.

But "scope" can describe
a number of sometimes-contradictory use-cases,
which can't all be solved using the same primitives.
Shadow-DOM starts from a few assumptions
that make sense in very specific use-cases,
but do not describe the majority of web design:

- Scoped styles match 1:1 with scoped elements in the DOM
- Scopes nest, but they do not overlap
- By default, no selectors should cross the encapsulation boundary

Yu Han has
an [interesting proposal][han]
in two parts,
designed to improve shadow-DOM,
by providing some more flexibility:

1. Allow shadow-DOM elements to opt-in to global styles
2. Allow light-DOM elements to opt-in to style isolation

[han]: https://docs.google.com/document/d/1hhjmuQE6BTTnAyKP3spDr8sU6lpXArh8LDfihZh78hw/edit?usp=sharinghttps://docs.google.com/document/d/1hhjmuQE6BTTnAyKP3spDr8sU6lpXArh8LDfihZh78hw/edit?usp=sharing

I think those proposals
(along with declarative shadow-DOM)
would be very helpful for making strong isolation
more flexible.
But even with that added flexibility,
many of the assumptions & limitations remain.

Shadow-DOM is simply not designed
for the common "design system" approach,
where patterns overlap in more fluid ways,
and global styles are expected to "flow through"
and tie all the pieces together.

### Are scope attributes useful in html?

Many scope proposals include
a scope attribute in HTML.
That's required for the full-isolation use-case --
where elements need to opt-in or out of global page styles up-front.
But following that path would make scope
much more similar to shadow-DOM
in it's limitations:

- Either we need a way to define lower-boundaries in the markup as well,
  or we make scopes exclusive/non-overlapping
- Authors have to manage scope in both HTML and CSS

Some authors might appreciate the
"automatic" nature of that approach,
but they could achieve the same goals
with a naming convention:

```css
p { color: blue; }

@scope ([data-scope=main]) to ([data-scope]) {
  p { color: green; }
}
@scope ([data-scope=note]) to ([data-scope]) {
  p { color: gray; }
}
```

```html
<p>This text is blue</p>
<section data-scope="main">
  <p>This text is green</p>
  <div data-scope="note">
    <p>This text is gray</p>
  </div>
</section>
<div data-scope="note">
  <p>This text is gray</p>
</div>
```

### Would we need special handling around the shadow-DOM?

This should have no impact on existing shadow DOM behavior.
Scoped styles can be used either in light or shadow DOM.
All scopes & scoped styles continue to respect the shadow boundary,
the same as any other CSS rules.

There are still some
[questions raised by Rune Lillesveen](https://github.com/w3ctag/design-reviews/issues/593#issuecomment-768992509)
about what selectors
would be allowed inside
a shadow-DOM encapsulated scope rule:

> For selectors in @scope rules in shadow trees,
> we should figure out which restrictions apply wrt
> matching elements outside the shadow tree.
> `@scope` rules in shadow trees should not be able
> to target elements outside the shadow tree,
> but what about `:host`/`:host-context`?
>
> - `@scope (:host(.a))` : should not match
> - `@scope (:host(.a) .b)` : should match?
> - `@scope (::slotted(.a))` : should not match
> - `@scope (::part(my-part))` : should not match

### Can tree-abiding pseudo elements be scope roots?

This issue was also
[raised by Rune](https://github.com/w3ctag/design-reviews/issues/593#issuecomment-768992509).

Is this allowed?

```css
@scope (div::before) {
  :scope { content: "xxx" }
}
```

I don't know of any use-case for it,
and would defer to input from implementors.

### A JS API for fetching "donut scope" elements?

Given a tree fragment,
JS is able to match elements _within_ a donut scope:

```js
const matches = root.querySelectorAll(":not(:scope boundary *)");
```

But that is only possible one element at a time,
and JS does not provide any way to
fetch "donuts" initially.

The proposed `:in()` pseudo-class
might allow authors to target elements
that fall within a donut,
but not to return a tree fragment of the donut itself:

```js
document.querySelectorAll("<element>:in(<root> / <boundary>)");
```

In order to return a donut tree fragment,
I think we would need
a second "exclusions" parameter
on methods like `querySelector()` and `querySelectorAll()`:

```js
document.querySelector("root", "boundary");
```

But I am not an expert
on these JS issues,
and would welcome more input.

### How does scope interact with the nesting module?

This proposal has some overlap with
the [CSS Nesting Module][nesting]
(currently an Editor's Draft).

[nesting]: https://drafts.csswg.org/css-nesting/

With the nesting syntax,
we could allow
the `@scope` rule to be nested inside
an existing selector block,
much like `@nest`,
and establish scope-root based on the outer selector.
In this case, the scope-root selector
_must be [nest-containing](https://drafts.csswg.org/css-nesting/#nest-containing)_
(have `&` somewhere in it),
with an implied value of `&`.
These three code-blocks
would have the same meaning:

```css
/* explicit scope with root */
@scope (.media) to (.content) {
  img { object-fit: cover; }
}

.media {
  /* nested scope with explicit nesting root */
  @scope (&) to (.content) {
    img { object-fit: cover; }
  }
}

.media {
  /*nested scope with implicit nesting root */
  @scope to (.content) {
    img { object-fit: cover; }
  }
}
```

However,
the goal of nesting is
to clean up document structure,
and make it more readable --
primarily a syntax issue.
Scope has a much more complicated set of goals,
around limited selector-matching
and namespacing.
There is also a clear difference
between the meaning of `&`
(which represents an entire selector list)
and `:scope`
(which represents a specific scoping element in the DOM).

While it might be a mistake to make one rely on the other --
they clearly have some overlap.
Both help to describe the relationship
between parent & child selectors.

### Can scope rules be nested in other scope rules?

I can imagine use-cases for nesting scope rules,
though I'm not aware of any tools that currently do this.
I believe we could describe a behavior
that works as expected.
Let's take, for example:

```css
@scope (.media) to (.content) {
   @scope (figure) to (figcontent) {
     img { border: red; }
   }
}
```

I would expect that to be
"flattened" into a single scope.
We can express that
using the proposed `:in()` donut selector
as part of the scope root:

```css
@scope (figure:in(.media / .content)) to (figcontent) {
  img { border: red; }
}
```

The `figure` itself would be considered
the scope-root.

### What happens when the root element matches the lower-boundary?

It's possible that authors
might use the same selector for both
the root and lower-boundary of a scope
(or use different selectors that match the same element):

```css
a { color: rebeccapurple; }

@scope (.dark-theme) to ([class*='-theme']) {
  a { color: plum; }
}
```

I would expect
the lower boundary to only match _descendants_
within each instance of the scope:

```html
<!-- outer scope root -->
<div class="dark-theme">
  <a href="#">plum</a>

  <!-- outer scope boundary -->
  <div class="light-theme">
    <a href="#">rebeccapurple</a>
  </div>

  <!-- outer scope boundary & nested scope root -->
  <div class="dark-theme">
    <a href="#">plum</a>
  </div>
</div>
```

Rather than applying to a single element
as both root and lower-bounds:

```html
<!-- outer scope root & self-boundary -->
<div class="dark-theme">
  <a href="#">rebeccapurple</a>
</div>
```

If there is a use-case for single-element scopes,
we could allow that using a more explicitly
self-referential syntax:

```css
@scope (.self) to (:scope) { /* ... */ }
```

Which would only match
selectors targeting the scope-root itself,
such as:

```css
@scope (.self) to (:scope) {
  .context :scope:focus { /* ... */ }
}
```

### Where does scope fit in the cascade?

For a more detailed exploration of this,
see my notes on [scope in the cascade](/scope/cascade/)

#### The 2014 scope proposal

The [original scope specification][initial-spec]
put scope above specificity in the cascade,
and the layering was importance-relative:

> For normal declarations the inner scope's declarations override,
> but for ''!important'' rules outer scope's override.

That would mean first
that scope takes precedence over specificity.
By default, the more locally-scoped style always wins:

In this example
from the outdated specification,
a paragraph matched by both selectors
would be green:

```css
@scope aside {
 p { color: green; }
}

aside#sidebar p { color: red; }
```

But the roles would reverse
when `!important` is used,
and the following example paragraph would be red:

```css
@scope aside {
 p { color: green !important; }
}

aside#sidebar p { color: red !important; }
```

#### Shadow-DOM encapsulation context

Shadow-DOM [encapsulation context][]
also comes above/before specificity in the cascade,
with an importance-reversal.
To quote the spec:

> When comparing two declarations
> that are sourced from different encapsulation contexts,
> then for normal rules the declaration from the outer context wins,
> and for important rules the declaration from the inner context wins.

This is the opposite of the original scope proposal,
and means:

> …normal declarations belonging to an encapsulation context
> can set defaults that are easily overridden by the outer context,
> while important declarations belonging to an encapsulation context
> can enforce requirements that cannot be overridden by the outer context.

[encapsulation context]: https://drafts.csswg.org/css-cascade-5/#cascade-context

#### The case for less isolation, and weak proximity

I have intentionally gone in the other direction,
making scope proximity _less powerful_ than specificity
in the cascade.
There is clearly interest in both strong & weak approaches to scope,
but I believe encapsulation context
can be expanded and improved on
for the high-isolation use-cases.
Meanwhile low-isolation scope has not been addressed.

By placing _scope proximity_
below/after specificity in the cascade,
I am explicitly & intentionally allowing
more global styles to flow through,
interact with,
and even override scoped styles:

```css
@​scope (aside) {
  p { color: green; }
}

aside#sidebar p { color: red; }
```

```html
<aside id="sidebar">
	<p>This is red</p>
</aside>
```

The primary use-case that I'm trying to address
is one in which component-styles are "locked-in"
to avoid cross-contamination,
but global styles are used to "tie it all together"
with consistent patterns like typography and branding.
The desired behavior is to prevent scoped styles from leaking out,
without getting in the way of global patterns
that should flow through easily.

If we give scope proximity more weight than specificity,
authors are left with very few tools to manage that relationship.
By putting proximity _below_ specificity,
authors can manage it in several ways:

- Adjust specificity to reflect desired priority,
  with equal specificity to trigger _proximity_ results
- Add lower boundaries to avoid overlap of styles

This _in-but-not-out_ approach
also matches the existing JS tools & CSS naming conventions
that authors already use.
Those tools add lower-boundaries,
and a single attribute-selector of increased specificity --
very easy to override from the global scope.
I think this low-weight approach to scope is also backed up by…

- much of the [long-running conversation on CSSWG][bring back scope]
- a [quick informal survey on Twitter][survey]
- Nicole Sullivan's [explainer from a couple years ago][nicole-scope]

Anecdotally,
I hear many CSS beginners surprised
that the fallback for specificity
is source-order rather than proximity.
This proposal would allow authors to opt-into
that expected proximity-over-source-order fallback behavior.

Meanwhile,
encapsulation could be expanded
for [use in the light DOM][isolation],
and proposal would continue to be distinct --
covering a significantly different set of use-cases.

[survey]: https://twitter.com/TerribleMia/status/1351247559738621952
[isolation]: https://docs.google.com/document/d/1hhjmuQE6BTTnAyKP3spDr8sU6lpXArh8LDfihZh78hw/edit?usp=sharinghttps://docs.google.com/document/d/1hhjmuQE6BTTnAyKP3spDr8sU6lpXArh8LDfihZh78hw/edit?usp=sharing
[nicole-scope]: https://docs.google.com/presentation/d/1Ki-IUCEWU-mNlS-019QVV9I9JsytvafQJHTxpBNfYvI/edit?usp=sharing

#### Alternative approaches to specificity

Existing tools
achieve donut scope
by appending a single attribute
to each selector.
If we wanted to match that behavior,
we could give `:scope`/`:in()`
the normal pseudo-class weight.
Given the following code:

```css
@scope (#media) to (.content) {
  img { /* implied :scope ancestor */ }
  :scope img { /* explicit :scope ancestor */ }
}

img:in(#media / .content) { /* donut selector */ }
```

This approach would result in
a specificity of `[0, 1, 1]`
for each selector.

Another option
would be to remove scope from specificity entirely –
for a final weight of `[0, 0, 1]`.
That would "simplify" the impact of scope on the cascade,
but at the expense of some clarity
about the relationships.

[Sara Soueidan has also proposed][scope-id]
giving `@scope` the selector-weight of an `#ID`.
That would acknowledge the targeting weight of scopes,
without making them override all specificity.
I can see the thought behind it,
but it seems less-intuitive & less flexible
than the alternatives.

[scope-id]: https://twitter.com/sarasoueidan/status/1351248295969103873?s=21

### Can we improve on the syntax?

The syntax could use some discussion,
especially around the proper label for lower boundaries.
There has been discussion of other keywords like `until`,
as well as a function syntax (eg `to(<selector>)`).
I'd also consider rephrasing to label these as "slots"
rather than "end-points":

```css
@scope root(.media-block) slots(.content) { /* ... */ }
```

## Spec History & Context

Besides the tooling that has developed,
there are several current & former specs
that are relevant here...

### CSS Scoping

- [First Public Working Draft][initial-spec]
- [Editors Draft](https://drafts.csswg.org/css-scoping/)

There is often pushback to the question of scope,
since the initial specification was never implemented,
and Shadow DOM was seen as a path forward.
While the current editors draft
is primarily concerned with Custom Elements & Shadow DOM,
this spec initially contained a full set of scoping features
that have since been removed:

A `<style scoped>` attribute,
which would apply styles
scoped to a particular DOM sub-tree.
This had a few limitations:

- Authors need to repeat styles in the DOM for every instance of the scope
- Those style need to live in distinct stylesheets

The use-cases that necessitate that approach
are now being handled by shadow encapsulation,
which frees us up to consider different use-cases now.

The spec also included `@scope` blocks in CSS,
which would help alleviate both issues.
Scoping has two primary effects:

1. The selector of the scoped style rule
   is restricted to match only elements within a subtree of the DOM
2. The cascade prioritizes scoped rules over un-scoped ones,
   regardless of specificity
3. Important declarations would flip the cascade order of scopes

Point 1 is limited by the need for lower scope boundaries,
or "donut scope".

Points 2 & 3 give scope _significant_ power in the cascade --
power that we now plan to provide through Cascade Layers.
While there are instances where the semantics of
layering, scoping, and containment
might reasonably overlap --
I think all three features are better off
with their own syntax.

In my proposal,
scope is only given a _minimal_ role in the cascade,
and mostly acts as a protection from naming conflicts.

### [CSS Selectors - Level 4](https://www.w3.org/TR/selectors-4/)

- [Scoped Selectors](https://www.w3.org/TR/selectors-4/#scoping),
  which only refer to a subtree or fragment of the document
- [Reference Element][scope-class]
  (`:scope`) pseudo-class ":scope elements" or the root of any scope
  (currently used in JS APIs only)

[scope-class]: https://www.w3.org/TR/selectors-4/#the-scope-pseudo

### [CSS Cascade - Level 4](https://www.w3.org/TR/css-cascade-4/)

- [Removes](https://www.w3.org/TR/css-cascade-4/#change-2018-drop-scoped)
  “scoping” from the cascade sort criteria,
  because it has not been implemented.
- Adds [encapsulation context](https://www.w3.org/TR/css-cascade-4/#cascade-context)
  to the cascade, for handling Shadow DOM
  - Outer context wins for *normal* layer conflicts
  - Inner context wins for `!important` layer conflicts

## Stakeholder Feedback / Opposition

- Chromium : Positive --
  Google was involved in developing this proposal
- Gecko : No signals
- Webkit : No signals

## References & acknowledgements

Related/previous issues and discussions:

- [Bring Back Scope][]:
  - [@scope with lower-bounds](https://github.com/w3c/csswg-drafts/issues/3547#issuecomment-524206816)
  - [@scope with name & attribute](https://github.com/w3c/csswg-drafts/issues/3547#issuecomment-693022720)
- [Selector Boundaries](https://github.com/w3c/csswg-drafts/issues/5057)
- [CSS Namespaces](https://github.com/w3c/csswg-drafts/issues/270)
  ([priorities](https://github.com/w3c/csswg-drafts/issues/270#issuecomment-231586786))

[Bring Back Scope]: https://github.com/w3c/csswg-drafts/issues/3547

In addition to the open issue threads mentioned above,
thanks for valuable feedback and advice from:

- Anders Hartvoll Ruud
- Giuseppe Gurgone
- Ian Kilpatrick
- Keith Grant
- Kenneth Rohde Christiansen
- Lea Verou
- Mason Freed
- Nicole Sullivan
- Rune Lillesveen
- Sara Soueidan
- Tab Atkins
- Theresa O'Connor
- Una Kravets
- Yu Han

## Change log

### 2021.08.24

- LINK to [syntax comparison](/scope/syntax/)

### 2021.02.03

- CLARIFY approaches to specificity
- CLARIFY behavior when scope boundaries match scope root
  (e.g. `@scope (a) to (a)`)
- CLARIFY differences between scope and shadow-DOM
- CLARIFY shadow-DOM issues to be addressed
- CLARIFY redundant discussion sections
- CLARIFY donut scope in JS
- Discussion of tree-abiding pseudo elements as scope roots

### 2021.01.29

- CLARIFY reasons for using `:scope` rather than `&`

### 2021.01.28

- NEW: Add proposal for `:in()` donut-scope selector
- CHANGE: Update specificity definition to reflect pseudo-class alternative
- CHANGE: Remove `&` syntax, to avoid conflicts with nesting
- Detailed discussion of selector syntax
- Detailed discussion of JS API for fetching a donut scope
- Detailed discussion of scope-nesting

### 2021.01.27

- CHANGE: Follow the [nesting module][nesting] rules
  for combining specificity of the scope selector
  with specificity of nested/scoped selectors.
- CHANGE: Allow [nesting module][nesting] syntax
  to be used [in scoped selectors](#the--nesting-selector)
- CLARIFY: The scope-root is prepended (as an ancestor)
  to all scoped selectors
  unless explicitly placed by use of `&` or `:scope`
- CLARIFY: The placement of
  [scope in the cascade](#where-does-scope-fit-in-the-cascade),
  and my reasons for allowing specificity
  to flow-through scopes in a single direction

### 2021.01.18

- Update acknowledgements
- CHANGE: Require `:scope` pseudo-class in scoped selectors that reference
  [context outside of the scope](#can-scoped-selectors-reference-external-context)
- CLARIFY: Shadow DOM behavior (scope respects shadow boundaries)
- CLARIFY: question about selector-lists in scope-root syntax
- CLARIFY: consistently use parenthesis around scope-root selectors
- CLARIFY: additional discussion of scope in the cascade
- CLARIFY: fix typo in proximity example
